<HMTL><ART>
<P>
<P>
<fm>
<JNLINFO>
<A NAME=Copyright HREF=/boilerplate/copyright.html>&copy;
<PUBLISHER> 1997 Oxford University Press</PUBLISHER></A>
<B><PAGE>4570-4581</PAGE></B>
<MANNO ID=gka731_gml></JNLINFO>
<TABLE WIDTH=100%>
<TR>
<TD ALIGN=LEFT><A HREF="#foot" NAME="footbk"><IMG BORDER=0 SRC=/Resources/graphics/icons/footnote.gif ALT=Footnote></A></TD>
<TD ALIGN=CENTER><A HREF="../default.html#4570"><IMG BORDER=0 SRC=/Resources/graphics/icons/toc2.gif ALT=Table of Contents></A></TD>
<TD ALIGN=RIGHT>
<A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?uid=9358168&form=6&db=m&Dopt=r"><IMG BORDER=0 SRC=/Resources/graphics/icons/pubmed2.gif ALT=PUBMED_LOGO></A>
</TD>
</TR>
</TABLE>
<BR>
<H2><ATL>RAGA: RNA sequence alignment by genetic algorithm</ATL></H2>
<TITLE> RAGA: RNA sequence alignment by genetic algorithm</TITLE>
<AUG>
<B><AU><FNM><B>C&eacute;dric </B></FNM><snm><B>Notredame<SUP>1,</SUP>*</B></SNM></AU>, <AU><FNM><B>Emmet A. </B></FNM><snm><B>O'Brien<SUP>1,2</SUP></B></SNM></AU> and <AU><FNM><B>Desmond G. </B></FNM><snm><B>Higgins<SUP>1,2</SUP></B></SNM></AU></B>
<P>
<AFF><SUP>1</SUP>EMBL Outstation-The European Bioinformatics Institute, Welcome Trust Genome Campus, Hinxton, <cty>Cambridge</cty> CB10 1SD, <cny>UK</cny> and <SUP>2</SUP>Department of Biochemistry, University College, <cty>Cork</cty>, <cny>Ireland</cny></aff></AUG>
<P>
<re>Received July 23, 1997;</re> <acc>Revised and Accepted October 1, 1997
<B><ABS>
<P>
<B>ABSTRACT</B><abstext>
<P>
<P>
We describe a new approach for accurately aligning two homologous RNA sequences when the secondary structure of one of them is known. To do so we developed two software packages, called RAGA and PRAGA, which use a genetic algorithm approach to optimize the alignments. RAGA is mainly an extension of SAGA, an earlier package for multiple protein sequence alignment. In PRAGA several genetic algorithms run in parallel and exchange individual solutions. This method allows us to optimize an objective function that describes the quality of a RNA pairwise alignment, taking into account both primary and secondary structure, including pseudoknots. We report results obtained using PRAGA on nine test cases of pairs of eukaryotic small subunit rRNA sequence (nuclear and mitochondrial).</abstext>
</ABS></B>
</fm>
<bdy>
<SEC>
<B>
<H3><ST><B>INTRODUCTION</B></ST></H3>
</B>
<P>
Most methods of alignment are based on the primary structure of the sequences to be analysed (<A NAME=bbr1_1 HREF=#bb1>1 </A>). Alignment may be straightforward when the primary structure is conserved but becomes less and less accurate as the evolutionary distance increases. In the case of RNA it may be possible to use secondary structure information to supplement the weak primary structure information. Such alignments, using primary and secondary constraints, have been built for rRNAs (<A NAME=bbr2_1 HREF=#bb2>2 </A>,<A NAME=bbr3_1 HREF=#bb3>3 </A>). Their construction is at least partially manual and is usually based on identification of sets of correlated mutations which suggest secondary structure interactions.
<P>
One justification for such methods is the fact that accurate alignment is still the main non-experimental way to establish a reliable secondary structure for a long RNA molecule. The only other alternative is <I>ab initio</I> prediction. Several techniques of this type have been developed over time (<A NAME=bbr4_1 HREF=#bb4>4 </A>,<A NAME=bbr5_1 HREF=#bb5>5 </A>), but they recently received renewed attention through the use of stochastic heuristic-based approaches, like simulated annealing (<A NAME=bbr6_1 HREF=#bb6>6 </A>,<A NAME=bbr7_1 HREF=#bb7>7 </A>) and genetic algorithms (<A NAME=bbr8_1 HREF=#bb8>8 </A>,<A NAME=bbr9_1 HREF=#bb9>9 </A>). Nevertheless, they remain limited by the fact that our understanding of the <I>in vivo</I> folding process is still incomplete. In contrast, homology analysis based on alignments does not have these limitations. Multiple alignments reveal the positions of the sequences on which some constraints exist, regardless of the actual cause of these constraints. Several algorithms have been developed for aligning RNA sequences taking into account primary and secondary information. Some methods attempt to simultaneously align and fold sequences (<A NAME=bbr10_1 HREF=#bb10>10 </A>-<A NAME=bbr12_1 HREF=#bb12>12 </A>). Their main drawback is that they remain limited to sets of short sequences (&#60;200 nt long).
<P>
To reduce the complexity of this problem it is also possible to align a sequence (or a set of sequences) of unknown structure to some pre-established reference master structure. Such alignments include non-local interactions and their solution has been shown to be NP hard (<A NAME=bbr13_1 HREF=#bb13>13 </A>). Nevertheless, for small sequences sensible results can be obtained. Several methods of this type, based on the use of stochastic context free grammar (SCFG) for the description of RNA non-pseudoknotted secondary structure, have been described (<A NAME=bbr11_1 HREF=#bb11>11 </A>,<A NAME=bbr14_1 HREF=#bb14>14 </A>,<A NAME=bbr15_1 HREF=#bb15>15 </A>). Pseudoknots, however, are important motifs in RNA folding (<A NAME=bbr16_1 HREF=#bb16>16 </A>) and recently some new results have been obtained on this aspect of RNA analysis. This includes the work of Tabaska and Stormo (<A NAME=bbr17_1 HREF=#bb17>17 </A>) for aligning an RNA sequence to a pseudoknotted structure in polynomial time. Unfortunately, all these methods have the limitation of being computationally very expensive and therefore remain restricted to small sequences (&#60;200 nt long).
<P>
This problem can be partially overcome by heuristic methods. Corpet and Michot have described an approach of this type (<A NAME=bbr18_1 HREF=#bb18>18 </A>). In this case a heuristic allows identification of the portions of an alignment that can be made without using secondary structure information. The remaining portions, if they are small enough, can then be aligned using non-local interactions. This is done with a specialized dynamic programming algorithm. Although this algorithm is less efficient than that described for SCFG-based alignments, the heuristic filtering makes it possible, in some cases, to align long RNA molecules (e.g. >1500 nt). At the moment this is largely beyond the scope of any SCFG-based algorithm. Unfortunately, the algorithm cannot deal with very divergent sequences and does not support the computation of pseudoknots. As opposed to the SCFG-based scoring scheme, that used by Corpet and Michot has no real theoretical justification. Nevertheless, it has the merit of being conceptually simple as well as leading to computation of sensible alignments (as judged by comparison with established reference alignments) (<A NAME=bbr18_2 HREF=#bb18>18 </A>).
<P>
For this reason we took the overall approach and scoring scheme of Corpet and Michot but used a genetic algorithm (GA) to carry out the optimization. This has two significant advantages. Firstly, in the GA context there is no difference between the handling of pseudoknots and any other secondary structure. Secondly, it is possible to attempt to find alignments between much longer sequences, such as complete small subunit rRNAs, which can be >2000 nt in length. The genetic algorithms (GA) (<A NAME=bbr19_1 HREF=#bb19>19 </A>,<A NAME=bbr20_1 HREF=#bb20>20 </A>), like simulated annealing (<A NAME=bbr21_1 HREF=#bb21>21 </A>) or Gibbs sampling (<A NAME=bbr22_1 HREF=#bb22>22 </A>), is a stochastic optimization technique. It involves an attempt at optimizing some cost function (objective function, OF) by modifying and combining a population of solutions (individuals). GAs do not guarantee an optimal solution, but are known to perform well with combinatorial or enumeration problems.
<P>
We based our approach directly on a previous package, SAGA (Sequence Alignment by Genetic Algorithm) (<A NAME=bbr23_1 HREF=#bb23>23 </A>). This algorithm was improved and parallelized. A suitable cost function that describes the quality of a RNA alignment was introduced, mostly based on the function described by Corpet and Michot (<A NAME=bbr18_3 HREF=#bb18>18 </A>). The package was name PRAGA for Parallel RNA Alignment by Genetic Algorithm. We compared this algorithm with traditional techniques of sequence alignment and, to some extent, with the program RNAlign (<A NAME=bbr18_4 HREF=#bb18>18 </A>).
</SEC>
<SEC>
<H3><ST><B>METHODS</B></ST></H3>
<P>
The aim is to align two related sequences of RNA, knowing the secondary structure (master structure) of one of them (master sequence), in order to predict the position of these structural elements in the second sequence (slave sequence). In the correct alignment elements of the two sequences sharing the same structure and/or sequence should be aligned (Fig. <A NAME=figr1_1 HREF=#fig1>1 </A>a-c). A measure (OF) can be designed that allows evaluation of the quality of such an alignment. This measure takes into account the quality of the sequence alignment and the stability of the folding induced by the master sequence onto the slave sequence. To produce the best scoring alignment according to this measure we used a GA. We also describe a parallel GA that we have designed to gain some speed over a serial one. The results obtained with several sets of sequences were compared with established reference alignments of the same sequences, using three comparison methods.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig1 HREF=raga_fig1.gif><IMG SRC=RAGA_small_fig1.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=1><A NAME=fig1 HREF=#figr1_1>1</A><B>.</B>RNA alignment. (<B>a</B>) Master sequence with a known secondary structure. (<B>b</B>) Alignment of the master sequence with a slave sequence of unknown structure using primary (Pr score) and secondary structure (Se score) information. (<B>c</B>) Prediction of the structural elements of the slave sequence shared with the master sequence.</fig><BR CLEAR=ALL>
<P>
<SEC>
<H3><ST><B>Objective function</B></ST></H3>
<P>
The function we use was described by Corpet and Michot (<A NAME=bbr18_5 HREF=#bb18>18 </A>). We implemented it in RAGA without any modification. It combines three different scores: Pr, the primary score; Se, the secondary score; a gap penalty score. The overall score is a combination of these three values. The higher this score, the better the alignment between the two sequences.
<P>
Pr is a function of the aligned pairs of residues in the alignment. It depends on a matrix where each possible pair of residues is given a score. In the case of RNA a simple identity matrix is used with a mismatch score of 0 and a match score of 1. All positions containing a gap are ignored at this point. Pr is therefore equal to the number of matches in the pairwise alignment.
<P>
Se is based on the secondary structure. It evaluates the stability of the folding induced by the master onto the slave sequence. If two nucleotides form a base pair (part of a stem) in the master, then the two nucleotides in the slave sequence aligned with them should be able to form a Watson-Crick base pair as well if the secondary structure is conserved. Since pairings are relatively well defined in RNA, it is possible to assign a score to the pairing potential of the sequence of unknown structure. This can be formalized as follows. Given two sequences A (master) and B (slave) with (A<SUB>i</SUB>,A<SUB>j</SUB>) being two nucleotides of A and (B<SUB>k</SUB>,B<SUB>n</SUB>) the equivalent aligned nucleotides of B, if A<SUB>i</SUB> and A<SUB>j</SUB> are known to be paired, A<SUB>i</SUB> is aligned with B<SUB>k</SUB> and A<SUB>j</SUB> with B<SUB>n</SUB> then the score Se is equal to the pairing score of B<SUB>k</SUB> with B<SUB>n</SUB>. In practice, a very simplified model was used to assign pairing scores, giving 2 for GC pairs and 1 for UA and UG pairs (UG is not a conventional Watson-Crick base pair but stems in RNA frequently contain UG pairs) or any other interaction involving one of the wildcards X or N. The other pairs are given a score of 0. Se is the sum of the scores associated with each pair in the structure of B induced by the structure of A.
<P>
It is usually necessary to insert gaps into one or both sequences in order to perform the alignment. These gaps represent insertion or deletion events that have occurred over time in both sequences. They may not occur completely at random and may happen more frequently in loops or in non-structured domains. In order to reflect this in the OF, two position-specific gap penalties are used following the model of Corpet and Michot (<A NAME=bbr18_6 HREF=#bb18>18 </A>): GOS, a penalty for opening a gap between two stacked pairs; GO, a penalty for opening a gap in non-structured regions.
<P>
A third penalty (GEP) is used to penalize gap length. It is calculated as GEP &times; length of gap. Terminal gaps are not penalized. We use the values proposed by Corpet and Michot with GO = 5, GOS = 8, GEP = 0.3. The total gap penalty of an alignment is equal to:
<TABLE WIDTH=100%>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>gap penalty = (<I>a</I> &times; GOS) + (<I>b</I> &times; GO) + (<I>c</I> &times; GEP)</TD>
<TD VALIGN=TOP ALIGN=RIGHT><B>1</B></TD>
</TR>
</TABLE>
<P>
Where <I>a</I> is the number of gaps between stacked pairs in stems, <I>b</I> is the number of other non-terminal gaps and <I>c</I> is the total length of all the non-terminal gaps. The complete alignment score is calculated using a new parameter [lambda], which is always a positive value.
<TABLE WIDTH=100%>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>alignment score = Pr + ([lambda] &times; Se) - gap penalt</TD>
<TD VALIGN=TOP ALIGN=RIGHT><B>2</B></TD>
</TR>
</TABLE>
<P>
The parameter [lambda] has the effect of balancing the contribution from primary structure information and from secondary structure.
</SEC>
<SEC>
<H3><ST><B>Optimization of the objective function</B></ST></H3>
<P>
The function in equation <B>2</B> was shown to be a good indicator of the quality of an alignment (<A NAME=bbr18_7 HREF=#bb18>18 </A>). The main drawback is that its optimization is difficult when [lambda] is given a value other than 0. In the case of [lambda] = 0 the contribution of secondary structure to the alignment is ignored. Such a function can be optimized by regular dynamic programming with local gap penalties (<A NAME=bbr1_2 HREF=#bb1>1 </A>,<A NAME=bbr24_1 HREF=#bb24>24 </A>). However, when [lambda] is not zero optimization becomes much harder. A variation of dynamic programming has been described. It requires O(<I>M</I><SUP>2</SUP><I>N</I><SUP>2</SUP>) space and O(<I>M</I><SUP>2</SUP><I>N</I><SUP>3</SUP>) time (<A NAME=bbr18_8 HREF=#bb18>18 </A>), <I>M</I> and <I>N</I> being the lengths of the sequences or profiles to align. Such a high complexity makes it hard to apply this algorithm to anything other than small sequences or fragments of alignments. Another limitation of this approach is that it cannot easily deal with pseudoknots. In order to overcome these two problems we used a GA.
<P>
RAGA is derived from the Simple Genetic Algorithm described by Goldberg (<A NAME=bbr20_2 HREF=#bb20>20 </A>). It involves using a population of solutions which evolve by means of natural selection. The population we consider is made of pairwise alignments. Initially a generation zero (G<SUB>0</SUB>) is created (initialization). In this population each individual consists of one possible alignment for the sequences to be aligned. The size of this population is kept constant. To go from one generation to the next, children are derived from parents that are chosen by some kind of `natural selection', based on their fitness as measured by OF (i.e. the better the parent, the more children it will have). To create a child an operator is selected that can be a crossover (mixing the contents of the two parents) or a mutation (modifying a single parent). There are several types of mutations, modifying the alignments in different ways. Each of these has a probability of being chosen that is dynamically optimized during the run (dynamic scheduling).
<P>
These steps are repeated iteratively, generation after generation (evaluation/breeding). During these cycles new pieces of alignment appear because of the mutations and are combined by the crossovers. This selection makes sure that good pieces survive and dynamic setting of the operators helps the population to improve by creating the children it needs. Following this simple process the average fitness of the population increases until no more improvement can be made. The best alignment obtained in this way is taken as a result.
<P><I>Initialization.</I> The first step of the algorithm is initialization, during which a population of solutions is created (seeding). The two desirable properties of an initial population are to have as much diversity as possible and to contain as many good scoring blocks as possible (i.e. individuals as good as possible). Seeding in a random manner allows one to have high diversity, but very few good scoring blocks. Such a population will usually improve slowly. On the other hand, seeding with greedy methods [e.g. ClustalW (<A NAME=bbr25_1 HREF=#bb25>25 </A>) and other alignment software] gives a population with a better initial score at the cost of lower diversity. Such a population usually improves very quickly, but tends to get stuck into a local minimum close to the starting point.
<P>
In RAGA we tried to find a good trade-off between these two extremes. A variation on dynamic programming described by Gerstein (<A NAME=bbr26_1 HREF=#bb26>26 </A>) was used to produce our initial alignments. This method (Dynamic Programming with Added Noise, DPAN in this paper) allows addition of a random amount of noise to the regular dynamic programming method (<A NAME=bbr27_1 HREF=#bb27>27 </A>,<A NAME=bbr28_1 HREF=#bb28>28 </A>), therefore producing sub-optimal alignments centred around the mathematical optimum obtained by dynamic programming without noise. In practice, when two sequences are aligned several times with DPAN long stretches of conserved residues tend to be kept intact, while diversity accumulates in less stable regions of the alignment. It is possible to control the overall amount of noise added. In RAGA this noise was tuned so that the average score of the alignments used for seeding would be the same as the average score of a population of random alignments. Even with such a bad initial average score, a population generated in this way improves about three times faster than a completely random population.
<P>
<I>Evaluation/breeding/end.</I> The rest of the GA procedures involved in RAGA are taken directly from SAGA. Individuals are first evaluated through the OF described earlier and then given an expected offspring score that reflects their quality in comparison with the rest of the individuals of the same generation. At each generation half of the population (lowest scoring alignments) is replaced by newly generated individuals (children). To produce a child an operator is selected (mutation or crossover). In the case of a mutation one parent is chosen to which the mutation is applied to produce a modified alignment that is put back into the population. In the case of a crossover the procedure is the same, but two parents are used. Children are put back into the population only when they are different from all the other children (population without duplicates). The selection of a parent is made by weighted wheel selection, a standard practice in GA: a virtual wheel is spun where each individual has a number of slots proportional to its expected offspring. Therefore the fittest are more likely to be chosen as parents, while the weakest still have a chance to survive.
<P>
Each operator has a probability of being used which varies along the run, depending on how well it performed. This automatic process is known as dynamic scheduling of the operators and has been described in greater detail (<A NAME=bbr19_2 HREF=#bb19>19 </A>,<A NAME=bbr23_2 HREF=#bb23>23 </A>). When no improvement has been made for a specified number of generations (typically 100 generations on a run of 400 generations), the GA is stopped.
<P>
<I>The operators.</I> According to the traditional nomenclature of genetic algorithms (<A NAME=bbr20_3 HREF=#bb20>20 </A>) two types of operators are used in RAGA: crossovers and mutations. In RAGA we do not make any distinction between these two types with regard to how we apply them. They are designed as independent programs that input one or two alignments (the parents) and output one alignment (the child). The difference in score between the input and output is used for future evaluation of the usefulness of the operator. Each operator requires one or more parameters which specify where and how the operation is to be carried out. For instance, an operator inserting a new gap must be told where (at which position in the alignment) and in which sequences the gap is to be inserted and how long this gap will be. The operators display several levels of greediness. Some are completely stochastic (i.e. the values of the parameter are determined randomly in some reasonable range), while others aim at some local optimization and rely on enumeration or DPAN.
<P>
<I>The crossovers.</I> These operators allow good pieces to be recombined and therefore play a central role in improving the population. In RAGA only one type of crosover is implemented: the uniform crossover (UCO) previously used in SAGA. The principle is to map the areas of alignment which are consistent (identical) between the two parents. The child will contain all these identical blocks as well as non-identical blocks taken from either of the parents. The choice of a non-consistent block can be random or deterministic. Both versions (random and deterministic) are implemented in RAGA.
<P>
<I>Gap shifting.</I> In order to keep improving the population it is necessary to introduce new alignment configurations. This can be done by shifting gaps. To do so a gap is randomly chosen in an alignment and moved to another position. The choice of the new position can be random or greedy, in which case the gap is slowly shifted in one direction as long as the score of the alignment keeps improving.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig2 HREF=raga_fig2.gif><IMG SRC=RAGA_small_fig2.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=2><A NAME=fig2 HREF=#figr2_1>2</A><B>.</B> Layout of the parallel genetic algorithm PRAGA. Each circle represents a RAGA process. The best individuals migrate from top to bottom. The best solution is to be found in the root (bottom).</fig><BR CLEAR=ALL>
<P>
<I>Gap insertion.</I> This operation is made by DPAN as described earlier. It is only performed on a portion of random size that is extracted from the alignment, re-aligned and re-introduced.
<P>
<I>Island parallelization.</I> In order to decrease run times we implemented an island parallelization model (<A NAME=bbr20_4 HREF=#bb20>20 </A>). Instead of having a single copy of RAGA, several identically configured GAs were used, running independently in parallel and exchanging individuals every <I>N</I> generations, where <I>N</I> is typically 5. The algorithms are arranged on a k-branched tree and population exchange only takes place in one direction, from the leaves to the bottom of the tree (Fig. <A NAME=figr2_1 HREF=#fig2>2 </A>). By default the individuals migrating from one RAGA to another are those having the best score. They replace individuals with lower scores in the node to which they move. The node from which they come keeps a copy, so that in each RAGA process the population remains constant.<fig ID="02">
<P>
We found that this model gives results comparable with what would be obtained with a single copy of RAGA having a population equivalent to the overall population of all the GAs. By default, after trial and error optimization, we used a three-branched tree with a depth of three, as shown in Figure <A NAME=figr2_2 HREF=#fig2>2 </A>. This model requires 13 GAs. The processes are synchronous and wait for each other to reach the same generation number before exchanging their populations. In terms of CPU time this implementation can be ~10 times faster than a single GA with the same overall population. This means that we get ~80% of the maximum speed-up. A typical population size for each GA is 30 and population migration occurs every five generations. A GA that receives new individuals (node) replaces half of its population that way (15 individuals). These 15 individuals are made up of three groups of five individuals coming from the previous nodes/leaves. This parallel GA was named PRAGA for Parallel RNA Alignment Genetic Algorithm. All of our results were obtained using PRAGA.
</SEC>
<SEC>
<H3><ST><B>Test cases</B></ST></H3>
<P>
To assess the efficiency and accuracy of PRAGA several test cases were designed. We used aligned rRNA sequences, obtained from a manual expert alignment of small subunit (SSU) sequences (<A NAME=bbr29_1 HREF=#bb29>29 </A>). This database contains large alignments of rRNA made by hand. These alignments come with predicted secondary structure. To build a test case two sequences were extracted from a multiple alignment. This initial alignment was kept as a reference. From the same alignment the structure (master structure) of one of the two sequences (master sequence) was then extracted. In this structure we kept only the elements documented as belonging to the conserved core which is found in most SSU rRNAs (<A NAME=bbr30_1 HREF=#bb30>30 </A>,<A NAME=bbr31_1 HREF=#bb31>31 </A>). These elements were chosen because they were likely to exist in the second sequence (slave sequence).
<P>
We designed two large test cases (test cases 1 and 2 in Table <A NAME=tblr01_1 HREF=#tbl01>1 </A>) using full-length eukaryotic nuclear sequences. These two sets use the human SSU rRNA as a master sequence and <I>Oxytrichia nova</I> and <I>Giardia ardeae</I> as slaves. These sequences are 65 and 75% identical respectively to the master human sequence. The purpose of these two test cases is to show the ability of the GA to optimize long alignments consisting of sequences of ~2 kb in length. In order to obtain test cases with a wider range of identity between the master and the slave sequence we turned to the mitochondrial SSU rRNA sequences. These sequences diverge faster than their nuclear counterparts (<A NAME=bbr32_1 HREF=#bb32>32 </A>), have a wider spectrum of identity and are also generally smaller (~1-1.5 kb in length). This allowed an extensive study of some of the properties of our algorithm. This set of seven test cases (Table <A NAME=tblr01_2 HREF=#tbl01>1 </A>, test cases 3-9) was created using the procedure already described. Sequences and structures were extracted from the database alignment (<A NAME=bbr29_2 HREF=#bb29>29 </A>). We used the human mitochondrial SSU rRNA as a master sequence and seven other mitochondrial sequences as slaves. Their identity with the human sequence ranges from 70 to 43%. Some of the slave sequences do not contain all the structural elements described in the core structure used for the alignment (Table <A NAME=tblr01_3 HREF=#tbl01>1 </A>, pairs column). This gave us a chance to analyse the effect of this type of noise on our optimization procedure.
<P>
The distances between the two sequences of a given test case were measured using the program Dnadist in the package Phylip (<A NAME=bbr33_1 HREF=#bb33>33 </A>). We used this program to assess the `Kimura with 2 parameters' distance (<A NAME=bbr34_1 HREF=#bb34>34 </A>), with a default `transition/transvertion' ratio set to 2 and one category of substitution rates.
</SEC>
<P>
Table <A NAME=tbl01 HREF=#tblr01_1>1 </A><B>. </B>
<caption>Test cases and general results</caption>
<TABLE BORDER>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>TC</TD>
<TD ALIGN=LEFT VALIGN=TOP>Master</TD>
<TD ALIGN=LEFT VALIGN=TOP>Slave</TD>
<TD ALIGN=LEFT VALIGN=TOP>Distance</TD>
<TD ALIGN=LEFT VALIGN=TOP>Pairs (%)</TD>
<TD ALIGN=LEFT VALIGN=TOP>Length</TD>
<TD ALIGN=LEFT VALIGN=TOP>[lambda]</TD>
<TD ALIGN=LEFT VALIGN=TOP COLSPAN=2>m1 (%)</TD>
<TD ALIGN=LEFT VALIGN=TOP COLSPAN=2>m2 (residues)</TD>
<TD ALIGN=LEFT VALIGN=TOP COLSPAN=2>m3 (%)</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>DP</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA</TD>
<TD ALIGN=LEFT VALIGN=TOP>DP</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA</TD>
<TD ALIGN=LEFT VALIGN=TOP>DP</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA</TD>
</TR>
<TR></TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>1</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I></TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Oxytrichia nova</I></TD>
<TD ALIGN=LEFT VALIGN=TOP>0.41</TD>
<TD ALIGN=LEFT VALIGN=TOP>82.5</TD>
<TD ALIGN=LEFT VALIGN=TOP>1914</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>83.9</TD>
<TD ALIGN=LEFT VALIGN=TOP>86.6</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.15</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.06</TD>
<TD ALIGN=LEFT VALIGN=TOP>85.3</TD>
<TD ALIGN=LEFT VALIGN=TOP>94.7</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>2</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I></TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Giarda ardeae</I></TD>
<TD ALIGN=LEFT VALIGN=TOP>0.57</TD>
<TD ALIGN=LEFT VALIGN=TOP>82.1</TD>
<TD ALIGN=LEFT VALIGN=TOP>1895</TD>
<TD ALIGN=LEFT VALIGN=TOP>3.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>72.2</TD>
<TD ALIGN=LEFT VALIGN=TOP>76.1</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.53</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.45</TD>
<TD ALIGN=LEFT VALIGN=TOP>65.2</TD>
<TD ALIGN=LEFT VALIGN=TOP>81.3</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>3</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Latimeria chalumnae</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.31</TD>
<TD ALIGN=LEFT VALIGN=TOP>81.2</TD>
<TD ALIGN=LEFT VALIGN=TOP> 998</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>85.9</TD>
<TD ALIGN=LEFT VALIGN=TOP>92.5</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.64</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.10</TD>
<TD ALIGN=LEFT VALIGN=TOP>82.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>96.1</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>4</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Xenopus laevis</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.43</TD>
<TD ALIGN=LEFT VALIGN=TOP>84.9</TD>
<TD ALIGN=LEFT VALIGN=TOP> 985</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>83.9</TD>
<TD ALIGN=LEFT VALIGN=TOP>92.5</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.41</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.20</TD>
<TD ALIGN=LEFT VALIGN=TOP>77.4</TD>
<TD ALIGN=LEFT VALIGN=TOP>96.7</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>5</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Drosophila virilis</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.76</TD>
<TD ALIGN=LEFT VALIGN=TOP>82.6</TD>
<TD ALIGN=LEFT VALIGN=TOP> 973</TD>
<TD ALIGN=LEFT VALIGN=TOP>3.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>66.8</TD>
<TD ALIGN=LEFT VALIGN=TOP>76.6</TD>
<TD ALIGN=LEFT VALIGN=TOP> 2.08</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.59</TD>
<TD ALIGN=LEFT VALIGN=TOP>48.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>68.5</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>6</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Apis mellifera</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.23</TD>
<TD ALIGN=LEFT VALIGN=TOP>72.1</TD>
<TD ALIGN=LEFT VALIGN=TOP> 977</TD>
<TD ALIGN=LEFT VALIGN=TOP>4.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>45.2</TD>
<TD ALIGN=LEFT VALIGN=TOP>56.0</TD>
<TD ALIGN=LEFT VALIGN=TOP> 3.83</TD>
<TD ALIGN=LEFT VALIGN=TOP>2.91</TD>
<TD ALIGN=LEFT VALIGN=TOP>24.1</TD>
<TD ALIGN=LEFT VALIGN=TOP>55.1</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>7</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Penicillium chrysogenum</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.26</TD>
<TD ALIGN=LEFT VALIGN=TOP>81.3</TD>
<TD ALIGN=LEFT VALIGN=TOP>1478</TD>
<TD ALIGN=LEFT VALIGN=TOP>4.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>37.7</TD>
<TD ALIGN=LEFT VALIGN=TOP>63.8</TD>
<TD ALIGN=LEFT VALIGN=TOP> 4.96</TD>
<TD ALIGN=LEFT VALIGN=TOP>3.21</TD>
<TD ALIGN=LEFT VALIGN=TOP>15.7</TD>
<TD ALIGN=LEFT VALIGN=TOP>77.0</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>8</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Chlamydomonas reinhardtii</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.30</TD>
<TD ALIGN=LEFT VALIGN=TOP>66.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>1271</TD>
<TD ALIGN=LEFT VALIGN=TOP>4.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>34.1</TD>
<TD ALIGN=LEFT VALIGN=TOP>53.2</TD>
<TD ALIGN=LEFT VALIGN=TOP>13.4</TD>
<TD ALIGN=LEFT VALIGN=TOP>8.26</TD>
<TD ALIGN=LEFT VALIGN=TOP> 8.90</TD>
<TD ALIGN=LEFT VALIGN=TOP>50.0</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>9</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Homo sapiens</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP><I>Saccharomyces cerevisiae</I> mitochondrion</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.33</TD>
<TD ALIGN=LEFT VALIGN=TOP>80.3</TD>
<TD ALIGN=LEFT VALIGN=TOP>1699</TD>
<TD ALIGN=LEFT VALIGN=TOP>6.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>31.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>60.2</TD>
<TD ALIGN=LEFT VALIGN=TOP>14.7</TD>
<TD ALIGN=LEFT VALIGN=TOP>3.70</TD>
<TD ALIGN=LEFT VALIGN=TOP>21.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>70.0</TD>
</TR>
</TABLE><tblfn>TC, test case number (as used in the text); Master, sequence with a known structure; Slave, sequence with an unknown structure, Distance, estimated mean number of substitutions per site between the master and the slave measured on the reference alignment; Pairs, pairs defined in the core structure of the master and present in the slave sequence, as judged from the reference alignment; Length: length of the reference alignment; [lambda], optimal value of [lambda], measured from graphs similar to those shown in Figure 4 [in cases where the three graphs (m1, m2, m3) did not indicate the same optimum we chose a value that was at least consistent with two of the graphs]; m1, measure m1 (overall level of identity with the reference alignment) obtained by dynamic programming with local gap penalties alignment (DP) or by PRAGA alignment obtained with the optimal [lambda] (PRAGA); m2, average offset measured on the structure (m2 should be as small as possible); m3, percent of pairs found correctly aligned (the reference is the number of pairs in the master core structure conserved in the slave sequence). The sequence EMBL accession nos are as follows: <I>Homo sapiens</I>, X03205; <I>Homo sapiens</I> mitochondrion, V00702; <I>Oxytrichia nova</I>, X03948; <I>Giarda ardeae</I>, Z177210; <I>Latimeria chalumnae</I> mitochondrion, Z21921; <I>Xenopus laevis</I> mitochondrion, M27605; <I>Drosophila virilis</I> mitochondrion, X05914; <I>Apis mellifera</I> mitochondrion, S51650; <I>Penicillium chrysogenum</I> mitochondrion, L01493; <I>Chlamydomonas reinhardtii</I> mitochondrion, M25119; <I>Saccharomyces cerevisiae</I> mitochondrion, V00702.
<SEC>
<H3><ST><B>Evaluation</B></ST></H3>
<P>
PRAGA was evaluated by comparing the results on the test cases with results obtained using traditional dynamic programming, RNAlign and by comparison with the reference alignments. Dynamic programming was implemented using Gotoh's algorithm (<A NAME=bbr35_1 HREF=#bb35>35 </A>) with local gap penalties, so as to make it comparable with optimizing the OF with [lambda] = 0. Due to the length of the sequences and the memory requirement, it was only possible to run RNAlign (<A NAME=bbr18_9 HREF=#bb18>18 </A>) on two of the test cases (3 and 5).
<P>
Comparison of an alignment with the reference taken from the databases can be done in several ways. We use three different measures: m1, m2 and m3. m1 is the percentage of the aligned columns of nucleotides in the reference alignment that are reproduced in the test alignment (columns with gaps are ignored). m2 is based on the alignment of stems. It is the average offset of stems between the reference and the test alignment. If a position A<SUB>k</SUB> of the master sequence is aligned with B<SUB>i</SUB> in the reference alignment and with B<SUB>j</SUB> in the new alignment the offset will be (i - j). m2 is equal to the average of each offset absolute value. The better the alignment, the smaller m2. The main advantage of m2 is that it takes into account some close sub-optima that would otherwise be completely disregarded by m1. Giving some credit to these types of alignments makes sense, especially when aligning similar structures with very divergent sequences. m3 is a measure very similar to m1. In m3 we only consider residues that form a pair in the secondary structure (stems). To be considered correctly aligned both residues of a pair must be aligned in a similar way to the reference. m3 is the percentage of such residues over the total number of pairs in the common core structure.
</SEC>
<SEC>
<H3><ST><B>Implementation</B></ST></H3>
<P>
RAGA and PRAGA are written in ANSI C and run under UNIX. PRAGA can be run on a variety of different UNIX platforms as long as they can each run RAGA. For RAGA the memory requirement is ~20 MB for an average alignment length close to 2000 regardless of the population size. A beta release for PRAGA and RAGA is available free of charge from the corresponding author by Email request, including `RAGA or PRAGA' in the title.
</SEC>
</SEC>
<SEC>
<H3><ST>RESULTS</ST></H3>
<SEC>
<B>
<H3><ST><B>Dynamic programming reference</B></ST></H3>
</B>
<P>
For each test case a pairwise alignment was produced using dynamic programming with local gap penalties. Another was made without local penalties using ClustalW. We compared these alignments to their reference using m1, m2, m3 and found that alignments made with local penalties were ~10% (as measured with m1 and m3) more similar to the reference than alignments made without local gap penalties. We then measured the distance between the sequences in each reference alignment, as described in the previous section. Similarity to the reference alignment, using measures m1, m2 and m3, was plotted against these distances. As expected, we find that there is a clear correlation between the level of identity of the sequences aligned and the similarity of their pairwise alignment to the reference. In order to improve on these results we introduced secondary structure information into the alignment procedure and used PRAGA to do so.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig3 HREF=raga_fig3.gif><IMG SRC=RAGA_small_fig3.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=3><A NAME=fig3 HREF=#figr3_1>3</A><B>.</B> Complexity. (<B>a</B>) Time (in generations) required to find a solution as a function of [lambda]. The distances are as in Table 1 and measure the distance between the slave and the master sequence. Four test cases producing alignments of similar length were used (6, 5, 4 and 3, which have lengths comprised between 900 and 1000 nucleotides). (<B>b</B>) Time (in generations) needed to find an optimum as a function of alignment length. For each of the four test cases measures were made varying [lambda]. The four test cases used (6, 8, 7 and 9) have a comparable distance between the master and the slave sequence (1.23-1.33). In our system (see Methods) the time required for one generation was ~54 s.</fig><BR CLEAR=ALL>
<P>
</SEC>
<SEC>
<H3><ST><B>Efficiency and accuracy of PRAGA</B></ST></H3>
<P>
Since the optimization procedure is central to our work, we analysed PRAGA for its ability to perform this task. We looked at two criteria: the accuracy of optimization and the consistency of the results. Our algorithm, being a stochastic heuristic, can be expected to give different results when run several times with the same set of parameters. In order to have a program that is as reliable as possible one would like to minimize the level of variation from one run to another.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig4 HREF=raga_fig4.gif><IMG SRC=RAGA_small_fig4.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=4><A NAME=fig4 HREF=#figr4_1>4</A><B>.</B> Evaluation of optimum [lambda] on test case 7. (<B>a</B>) m1 and m3 (see Methods) were measured on the alignment produced by PRAGA with different values of [lambda]. (<B>b</B>) As (a) but with m2.</fig><BR CLEAR=ALL>
<P>
First, we checked, through the use of crossovers and mutations, that our program was able to reproduce the patterns of gaps and matches present in any of the reference alignments. We did so by using as an OF the measure of overall identity (m1) between a PRAGA alignment and the reference alignment. For all the test cases the GA was able to produce alignments 100% identical to the reference. Several runs were made for each test case that showed a total consistency in the scores. This is a good sign that PRAGA has the potential to explore the whole solution space when aligning two sequences.
<P>
Since dynamic programming with local gap penalties is equivalent to the OF described in the method with [lambda] = 0, we checked that when using such an OF PRAGA was able to reproduce the dynamic programming alignments. In all cases it managed to produce alignments having exactly the same score as the dynamic programming reference. Here again we found a very good consistency from run to run (&#60;0.1% deviation). When looking at the similarity between these alignments and the reference we found that the deviation was significantly higher (2.2% on m1, 2.1% on m3, 0.1 residues on m2). The highest variations were found for alignments where the two sequences aligned shared a low level of identity. This fact is not surprising, since it is well known that several alternative alignments of the same sequences can share the same score (<A NAME=bbr36_1 HREF=#bb36>36 </A>). This is simply a consequence of the OF properties.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig5 HREF=raga_fig5.gif><IMG SRC=RAGA_small_fig5.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=5><A NAME=fig5 HREF=#figr5_1>5</A><B>.</B> Optimal values of [lambda] as a function of the slave/master distance. For each test case the values of [lambda] leading to the best alignment were measured on plots similar to that shown in Figure 4 and plotted against the slave/master distance.</fig><BR CLEAR=ALL>[
<P>
In a second stage PRAGA was tested with values of [lambda] set between 1 and 9. Each test case was analysed, four runs being made with each value of [lambda]. Since no mathematical optimal solution was available to serve as a benchmark for these alignments, we focused our analysis on the consistency of the program. We found that overall the deviation of the score of equivalent alignments was &#60;0.5%. This deviation tended to remain constant with different values of [lambda]. The deviation of the score of the comparison with the reference alignment was higher (3.2% on m1, 2.1% on m2 and 0.4 residues on m3) and tended to increase slightly with higher values of [lambda]. In order to verify that the use of dynamic programming (DPAN) was not adding some uncontrolled bias, most of these experiments were repeated while switching off the DPAN seeding and DPAN mutation described in Methods. Results obtained in that way were consistent with the rest of our experiment. This also allowed us to confirm that the use of DPAN gives an ~3-fold speed-up to the optimization procedure and does not create any premature convergence problem.
<P>
Finally, an attempt was made to establish the complexity of the algorithm as a function of the different parameters (Fig. <A NAME=figr3_1 HREF=#fig3>3 </A>a and b). Due to the properties of the OF the time needed to compute one generation increases linearly with the average length of the alignments in the population. This average length is roughly similar to the length of a regular dynamic programming alignment. For a typical test case (7 in Table <A NAME=tblr01_4 HREF=#tbl01>1 </A>) the average time needed for one generation is of the order of 54 s CPU time. The number of generations needed to reach an optimal solution, however, is a function of several factors, including the value of [lambda], the length of the alignment and the similarity of the sequences. Our experiments show that the level of similarity has a significant effect on the time requirement. This is in agreement with previous observations made on protein sequences using a similar model of alignment (<A NAME=bbr23_3 HREF=#bb23>23 </A>). The complexity of the gap pattern (as seen from the point of view of the operators) tends to increase with the distance between the two sequences, making it harder for the GA to find the right configuration.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig6 HREF=raga_fig6.gif><IMG SRC=RAGA_small_fig6.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=6><A NAME=fig6 HREF=#figr6_1>6</A><B>.</B> Comparison of PRAGA and dynamic programming with local gap penalties using the m3 measure. Each point corresponds to one of the test cases in Table 1. PRAGA alignments were obtained using an optimal value for [lambda].</fig><BR CLEAR=ALL>
<P>
We also found (Fig. <A NAME=figr3_2 HREF=#fig3>3 </A>a) that for a fixed length and a fixed level of identity the number of generations needed to reach the optimum increases with [lambda]. However, more remarkable is that for [lambda] = 0 the number of generations required tends to be independent of the alignment length. This means that under these conditions the time requirement increases almost linearly with the sequence length (this observation holds when seeding is done in a random way). In theory this is a clear improvement over dynamic programming, which requires at least a quadratic amount of time. In practice, however, the overhead is so large that the sequences to be aligned would need to be extremely long (>10 000 nt) for this speed-up to become really noticeable and we still need to check that this linearity holds for such long sequences.
</SEC>
<SEC>
<H3><ST><B>Tuning of </B>[lambda]</ST></H3>
<P>
Corpet and Michot described their OF as giving the best results with [lambda] = 3. Since we aligned sequences with a wide range of identity, it was important to know whether [lambda] should be set to a value that is a function of the distance between the slave and the master sequence. For each of our seven test cases the accuracy, as measured by m1, m2 and m3, was plotted against [lambda]. Most of the graphs show reasonable continuity, as shown in Figure <A NAME=figr4_1 HREF=#fig4>4 </A>a and b. We deduced an optimal value for [lambda] from each of these graphs and found the results to be mostly consistent with each similarity measure used (m1, m2 or m3). Figure <A NAME=figr5_1 HREF=#fig5>5 </A> is a plot of `optimal [lambda]' against the slave/master distance. It shows that the value of [lambda] should roughly reflect the level of identity between the two sequences analysed. It should be higher for sequences of low identity and low for very similar sequences.
<P>
Our results also indicate that [lambda] is quite a robust parameter and that a variation of one or two around the optimal value has little effect on the actual quality of the alignment. Such a robustness means that one can perform a dynamic programming alignment beforehand, measure the distance (using Kimura or any other scheme) and deduce from this a reasonable [lambda]. For instance, [lambda] should be set to 1 for closely related sequences (distance &#60;0.5 estimated substitutions/site), 3 for more distantly related pairs (distance &#60;1) and 5 for more remote homologues (distance >1).
</SEC>
<SEC>
<H3><ST><B>Comparison with dynamic programming</B></ST></H3>
<P>
The new alignments generated with PRAGA were compared with those obtained by dynamic programming. In all cases (Fig. <A NAME=figr6_1 HREF=#fig6>6 </A>, Table <A NAME=tblr01_5 HREF=#tbl01>1 </A>) we found that using our method leads to a significant improvement over the dynamic programming approach regardless of the comparison measure. Although both methods follow the same trend and decrease in accuracy when the slave/master distance increases, PRAGA is clearly less affected than dynamic programming. The accuracy of the alignments produced by PRAGA is also clearly a function of the slave/master structural similarity. For instance, let us consider test cases 6-9. These alignments have comparable distances (1.23-1.33 estimated substitutions/site), therefore it seems that the factor responsible for the lower accuracy observed for 6 and 8 is mostly due to the fact that in these alignments the level of conservation of secondary structure is lower than for 7 and 9 (see column `pairs' in Table <A NAME=tblr01_6 HREF=#tbl01>1 </A>).<fig ID="06">
</SEC>
<SEC>
<H3><ST><B>Comparison with RNAlign</B></ST></H3>
<P>
An attempt was made to align each of the nine test cases using the program RNAlign (<A NAME=bbr18_10 HREF=#bb18>18 </A>). This was done on a Pentium PC with 64 MB memory. Only two of the test cases (3 and 5) could be aligned successfully. All the others caused the machine to run out of memory or the program to issue a warning message. For 3 and 5 we tuned [lambda] as we did for PRAGA. The optimal values found were the same as those reported with the GA. We found RNAlign alignments to be roughly similar to PRAGA with the three measures (for instance measure m3 gave 89.3% for test case 3 and 68.6 for 5). These results are quite consistent with those obtained with PRAGA (Table <A NAME=tblr01_7 HREF=#tbl01>1 </A>) and constitute one more piece of evidence that the optimization procedure is accurately performed by our program.
<P>
The reason why the other test cases could not be aligned has to do with the way RNAlign works. It first produces a dynamic programming alignment with local gap penalties. In the second stage it identifies some `anchor points' in this alignment. These are regions of the alignment that can be considered as correctly aligned, using some conservative evaluation scheme. During the last stage, considering the area in between the anchor points, RNAlign performs a complex dynamic programming that takes into account both primary and secondary structure constraints. This dynamic programming is very intensive in terms of time [O(<I>M</I><SUP>2</SUP><I>N</I><SUP>3</SUP>)] and memory [O(<I>M</I><SUP>2</SUP><I>N</I><SUP>2</SUP>)]. This means that when trying to align sequences with low levels of identity the setting of anchor points is difficult and leads the program to re-align stretches of the alignment much too long to be handled in that way. In practice, the longer the sequences, the more similar they need to be for RNAlign to align them. To overcome these limitations the authors use a multiple alignment (Bank) instead of a single master sequence. From this multiple alignment they remove areas of very low identity by a semi-automatic method and then use this reduced profile in RNAlign.
</SEC>
<SEC>
<H3><ST><B>Computation of pseudoknots</B></ST></H3>
<P>
Pseudoknots are structures that involve interaction of a loop with a domain on the 3'- or 5'-side of its stem (<A NAME=bbr16_2 HREF=#bb16>16 </A>,<A NAME=bbr37_1 HREF=#bb37>37 </A>). They can be considered as RNA tertiary motifs. Computationally, prediction of pseudoknots is very difficult using traditional approaches (<A NAME=bbr38_1 HREF=#bb38>38 </A>). In their method Corpet and Michot (<A NAME=bbr18_11 HREF=#bb18>18 </A>) had to exclude pseudoknots. It is interesting to notice that in the case of PRAGA there is no real distinction between a pseudoknot and any other type of Watson-Crick interaction. This means that the algorithm should have no more difficulty in aligning pseudoknots than normal stems. In the previous experiments, in order to remain consistent with RNAlign, we excluded these interactions from the master structure. In order to demonstrate the ability of PRAGA to deal with such structures we re-introduced some of them. We only considered pseudoknots involving more than two residues and associated through Watson-Crick interactions. By doing so it is possible to add 6 bp to the previously used structure. These base pairs are boxed in green in Figure <A NAME=figr7_1 HREF=#fig7>7 </A>a and b.
<P>
<P>
<BR CLEAR=ALL><FIGURE><A NAME=fig7 HREF=raga_fig7.gif><IMG SRC=RAGA_small_fig7.gif ALIGN=RIGHT HSPACE=18 VSPACE=10></A>
<P>
<LEGEND>
<P>
<B>Figure </B><FIG ID=7><A NAME=fig7 HREF=#figr7_1>7</A><B>.</B>Comparison of dynamic programming (<B>a</B>) and PRAGA (<B>b</B>) on test case 9. The boxed stems indicate stems that were included in the master structure (<I>Homo sapiens</I> mitochondrion). Blue portions are the elements not shared by the two structures (and therefore not part of the master structure). A stem is considered correctly aligned if at least one position of its alignment is strictly identical to the reference alignment. This scheme does not take pairing into account. This explains why it is possible to have only the left or the right strand of a stem correctly aligned. The pseudoknots boxed in green are those that were used in the alignment (see text).</fig><BR CLEAR=ALL>
<P>
The GA was then used with this new master structure, setting [lambda] to the optimal value previously reported. The experiment was performed on four of the test cases (4, 6, 7 and 9) and the results are given in Table <A NAME=tblr02_1 HREF=#tbl02>2 </A>. They show unambiguously that our program can efficiently use pseudoknot information in order to improve the alignment. It should be noted that the computation of pseudoknots has no noticeable effect on the algorithmic complexity previously discussed. The fact that even without having pseudoknots present in the master structure (Table <A NAME=tblr02_2 HREF=#tbl02>2 </A>, PRAGA-PN) PRAGA improves the alignment is due to the constraint imposed by other structures in the vicinity of these pseudoknots (see Fig. <A NAME=figr7_2 HREF=#fig7>7 </A>).
<P>
Table <A NAME=tbl02 HREF=#tblr02_1>2 </A><B>. </B>
<caption>Incorporating pseudoknot information</caption>
<TABLE BORDER>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>TC</TD>
<TD ALIGN=LEFT VALIGN=TOP>Distance</TD>
<TD ALIGN=LEFT VALIGN=TOP COLSPAN=3>m2 (residues)</TD>
<TD ALIGN=LEFT VALIGN=TOP COLSPAN=3>m3 (%)</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>&nbsp;</TD>
<TD ALIGN=LEFT VALIGN=TOP>DP</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA<BR>(Struc -PN)</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA<BR>(Struc +PN)</TD>
<TD ALIGN=LEFT VALIGN=TOP>DP</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA<BR>(Struc -PN)</TD>
<TD ALIGN=LEFT VALIGN=TOP>PRAGA<BR>(Struc +PN)</TD>
</TR>
<TR></TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>4</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.43</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>6</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.23</TD>
<TD ALIGN=LEFT VALIGN=TOP>2.80</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.61</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP> 16.6</TD>
<TD ALIGN=LEFT VALIGN=TOP> 50.0</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>7</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.26</TD>
<TD ALIGN=LEFT VALIGN=TOP>4.90</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.25</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP> 50.0</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
</TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>9</TD>
<TD ALIGN=LEFT VALIGN=TOP>1.33</TD>
<TD ALIGN=LEFT VALIGN=TOP>13.5</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.20</TD>
<TD ALIGN=LEFT VALIGN=TOP>0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP> 0.00</TD>
<TD ALIGN=LEFT VALIGN=TOP> 66.6</TD>
<TD ALIGN=LEFT VALIGN=TOP>100</TD>
</TR>
</TABLE>
<tblfn>Alignments were made incorporating into the master structure some of the positions known to form a pseudoknot (green boxes in Fig. 7). These positions make a total of six new pairs of nucleotides. The alignments were compared to the reference for their accuracy on the newly added positions. m2 and m3 were calculated on the new pairs. The results (Struc +PN) were compared with those obtained by dynamic programming with local gap penalties (DP) and by PRAGA without the pseudoknot information (Struc -PN).
<P></SEC>
</SEC>
<SEC>
<H3><ST><B>DISCUSSION</B></ST></H3>
<P>
PRAGA is a powerful tool for RNA alignment. Using existing structures allowed us to predict quite accurately the core structure of several ribosomal sequences, even those remotely related to the sequence for which the master structure was known. We also show that this type of analysis can capture some of the tertiary properties of the folding, such as pseudoknot interactions.
<P>
The next step with PRAGA will be implementation of an OF that allows the use of a whole alignment instead of a single master sequence. We are currently investigating ways of maximizing the information that can be extracted from such alignments (sequence weighting, local penalties, local substitution schemes, use of secondary structure, etc.). Using a GA gives us a lot of freedom in the design of the OF. In practice, almost any type of constraint or information can be built into an OF and used for optimization purposes. This could include, for instance, SCFG-based functions, which have sounder theoretical justifications than the function we have been using here (<A NAME=bbr39_1 HREF=#bb39>39 </A>). Another possible extension of PRAGA would be to use the alignment to predict non-conserved stems between correctly aligned core stems with traditional folding prediction methods (<A NAME=bbr4_2 HREF=#bb4>4 </A>). We are currently investigating ways of defining the local reliability of a given alignment in order to produce a complete structure.
<P>
The RAGA algorithm itself is mostly adapted from SAGA (<A NAME=bbr23_4 HREF=#bb23>23 </A>). This means that the operators used by RAGA were initially designed for aligning protein sequences (linear alignments). It is surprising that these operators do so well in a context where long range non-linear pairings are involved. We believe that this can be explained by the balance between potentially disruptive operators, such as crossovers, and the ability of the other operators (mutations) to fix these disruptions. This balance is automatically maintained by dynamic scheduling of the operators usage probability. It should be noted that the uniform crossover is much less disruptive than would be other forms of exchange, such as the one point crossover described for SAGA. In many cases the uniform crossover tends to respect long range interactions, simply because they often belong to stable parts of the alignment and are likely to be widespread in the population. This approach could probably be taken further and new operators could be designed with respect to the RNA tree structures (<A NAME=bbr40_1 HREF=#bb40>40 </A>) or using stochastic context-free grammar.
<P>
A very important aspect of PRAGA is its ability to deal with noise. By noise we mean unconserved secondary elements that are present in the master structure and absent in the slave structure. We have shown that although such elements significantly decrease the performance of our algorithm, overall, even in these cases, PRAGA remains significantly better than any other alternative we know of. In the future we will focus our attention on defining a better OF that would be able to discriminate this type of event, therefore minimizing their negative effect.
<P>
Although our algorithm has been specifically designed for aligning rRNA, it can in theory be applied to any structured RNA. An aspect of PRAGA that still needs to be studied would be its ability to discriminate between RNA structural homologues. The program is too slow to be used for scanning databases as it is now, but since it is a GA, it can also produce sub-optimal solutions in a shorter time. In our experience the quality of the solution found by PRAGA in the first 10% of a run is usually a good indicator of the overall score that may be reached after further optimization. This property could be used to design a `short PRAGA' as some sort of filter, later focusing the long runs on candidates having a potentially good structural match with some query sequence.
</SEC>
<SEC>
<H3><ST><B>ACKNOWLEDGEMENTS</B></ST></H3>
<P>
This work was partly supported by a grant from the EC Biotechnology Program (BIO4-CT95 0130). We wish to thank Burkhart Rost and Miguel Andrade for useful comments. We also wish to thank the three anonymous referees for their useful remarks and interesting suggestions.
</SEC>
</bdy><bm><bibl>
<H3>REFERENCES</H3>
<bb ID="b1"><A NAME=bb1 HREF=#bbr1_1>1 </A><AUTH>Needleman</AUTH>,<INITS>S.B. </INITS>and Wunsch,C.D. (<YR>1970</YR>) <I><JNL>J. Mol. Biol</JNL></I>., <B><VOL>48</VOL></B>, <PG>443</PG>-453.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=70205359&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b2"><A NAME=bb2 HREF=#bbr2_1>2 </A><AUTH>Michot</AUTH>,<INITS>B.</INITS>, Qu,L.H. and Bachellerie,J.P. (<YR>1990</YR>) <I><JNL>Eur. J. Biochem</JNL></I>., <B><VOL>188</VOL></B>, <PG>219</PG>-229.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=90201046&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b3"><A NAME=bb3 HREF=#bbr3_1>3 </A><AUTH>Gutell</AUTH>,<INITS>R.R.</INITS>, Weiser,B., Woese,C.R. and Noller,H.F. (<YR>1985</YR>) <I><JNL>Prog. Nucleic Acid Res. Mol. Biol</JNL></I>., <B><VOL>32</VOL></B>, <PG>155</PG>-216.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=86121781&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b4"><A NAME=bb4 HREF=#bbr4_1>4 </A><AUTH>Zuker</AUTH>,<INITS>M. </INITS>(<YR>1989</YR>) <I><JNL>Science</JNL></I>, <B><VOL>244</VOL></B>, <PG>48</PG>-52.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=89203248&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b5"><A NAME=bb5 HREF=#bbr5_1>5 </A><AUTH>Gouy</AUTH>,<INITS>M. </INITS>(1987) In Bishop,M.J. and Rawlings,C.J. (<YR>eds), <I>Nucleic Acid and Protein Sequence Analysis: A Practical Approach</I>. IRL Press, Oxford, UK, pp. 259-284.</BB><P>
<bb ID="b6"><A NAME=bb6 HREF=#bbr6_1>6 </A><AUTH>Schmitz</AUTH>,<INITS>M. </INITS>and Steger,G. (<YR>1996</YR>) <I><JNL>J. Mol. Biol</JNL></I>., <B><VOL>255</VOL></B>, <PG>254</PG>-266.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=96144847&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b7"><A NAME=bb7 HREF=#bbr7_1>7 </A><AUTH>Shapiro</AUTH>,<INITS>B.A. </INITS>and Wu,J.C. (<YR>1996</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>12</VOL></B>, <PG>171</PG>-180.</BB><P>
<bb ID="b8"><A NAME=bb8 HREF=#bbr8_1>8 </A><AUTH>Gultayaev</AUTH>,<INITS>A.P.</INITS>, van Batenburg,F.D.H. and Pleij,C.W.A. (<YR>1995</YR>) <I><JNL>J. Mol. Biol</JNL></I>., <B><VOL>250</VOL></B>, <PG>37</PG>-51.</BB><P>
<bb ID="b9"><A NAME=bb9 HREF=#bbr9_1>9 </A><AUTH>Ogata</AUTH>,<INITS>H.</INITS>, Yutaka,A. and Minoru,K. (<YR>1995</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>23</VOL></B>, <PG>419</PG>-426.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=95192051&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b10"><A NAME=bb10 HREF=#bbr10_1>10 </A><AUTH>Sankoff</AUTH>,<INITS>D. </INITS>(<YR>1985</YR>) <I><JNL>SIAM J. Applicat. Math</JNL></I>., <B><VOL>45</VOL></B>, <PG>810</PG>-825.</BB><P>
<bb ID="b11"><A NAME=bb11 HREF=#bbr11_1>11 </A><AUTH>Eddy</AUTH>,<INITS>S.R. </INITS>and Durbin,R. (<YR>1994</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>22</VOL></B>, <PG>2079</PG>-2088.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=94301791&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b12"><A NAME=bb12 HREF=#bbr12_1>12 </A><AUTH>Kim</AUTH>,<INITS>J.</INITS>, Cole,J.R. and Pramanik,S. (<YR>1996</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>12</VOL></B>, <PG>259</PG>-267.</BB><P>
<bb ID="b13"><A NAME=bb13 HREF=#bbr13_1>13 </A><AUTH>Lathrop</AUTH>,<INITS>R.H. </INITS>(<YR>1994</YR>) <I><JNL>Protein Engng</JNL></I>, <B><VOL>7</VOL></B>, <PG>1059</PG>-1068.</BB><P>
<bb ID="b14"><A NAME=bb14 HREF=#bbr14_1>14 </A><AUTH>Sakakibara</AUTH>,<INITS>Y.</INITS>, Brown,M., Underwood,R.C., Mian,I.S. and Haussler,D. (<YR>1994</YR>) In <I>27th Hawaii International Conference on System Sciences</I>. IEEE Computer Society Press, Los Alamitos, CA, pp. 284-293.</BB><P>
<bb ID="b15"><A NAME=bb15 HREF=#bbr15_1>15 </A><AUTH>Lefebvre</AUTH>,<INITS>F. </INITS>(<YR>1995</YR>) In <I>ISMB-95</I>. AAAI Press, CA, pp. 222-230.</BB><P>
<bb ID="b16"><A NAME=bb16 HREF=#bbr16_1>16 </A><AUTH>Pleij</AUTH>,<INITS>C. </INITS>(<YR>1990</YR>) <I><JNL>Trends Biochem. Sci</JNL></I>., <B><VOL>15</VOL></B>, <PG>143</PG>-147.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=90252305&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b17"><A NAME=bb17 HREF=#bbr17_1>17 </A><AUTH>Tabaska</AUTH>,<INITS>E.J. </INITS>and Stormo,G.S. (<YR>1997</YR>) In <I>ISMB-97</I>. AAAI Press, Menlo Park, CA, pp. 311-318.</BB><P>
<bb ID="b18"><A NAME=bb18 HREF=#bbr18_1>18 </A><AUTH>Corpet</AUTH>,<INITS>F. </INITS>and Michot,B. (<YR>1994</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>10</VOL></B>, <PG>389</PG>-99.</BB><P>
<bb ID="b19"><A NAME=bb19 HREF=#bbr19_1>19 </A><AUTH>Davis</AUTH>,<INITS>L. </INITS>(<YR>1991</YR>) <I><JNL>The Handbook of Genetic Algorithms</JNL></I>. Van Nostrand Reinhold, New York, NY.</BB><P>
<bb ID="b20"><A NAME=bb20 HREF=#bbr20_1>20 </A><AUTH>Goldberg</AUTH>,<INITS>D.E. </INITS>(<YR>1989</YR>) <I><JNL>Genetic Algorithms in Search</JNL>, Optimization and Machine Learning</I>. Addison-Wesley,<B><VOL> </B>New York, NY.</BB><P>
<bb ID="b21"><A NAME=bb21 HREF=#bbr21_1>21 </A><AUTH>Kirkpatrick</AUTH>,<INITS>S.</INITS>, Gelatt,C.D.J. and Vecchi,M.P. (<YR>1983</YR>) <I><JNL>Science</JNL></I>, <B><VOL>220</VOL></B>, <PG>671</PG>-680.</BB><P>
<bb ID="b22"><A NAME=bb22 HREF=#bbr22_1>22 </A><AUTH>Lawrence</AUTH>,<INITS>C.E.</INITS>, Altschul,S.F., Boguski,M.S., Liu,J.S., Neuwald,A.F. and Wootton,J.C. (<YR>1993</YR>) <I><JNL>Science</JNL></I>, <B><VOL>262</VOL></B>, <PG>208</PG>-214.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=94023958&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b23"><A NAME=bb23 HREF=#bbr23_1>23 </A><AUTH>Notredame</AUTH>,<INITS>C. </INITS>and Higgins,D.G. (<YR>1996</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>24</VOL></B>, <PG>1515</PG>-1524.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=96195583&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b24"><A NAME=bb24 HREF=#bbr24_1>24 </A><AUTH>Thompson</AUTH>,<INITS>J.D. </INITS>(<YR>1995</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>11</VOL></B>, <PG>19</PG>-29.</BB><P>
<bb ID="b25"><A NAME=bb25 HREF=#bbr25_1>25 </A><AUTH>Thompson</AUTH>,<INITS>J.</INITS>, Higgins,D. and Gibson,T. (<YR>1994</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>22</VOL></B>, <PG>4673</PG>-4690.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=95075648&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b26"><A NAME=bb26 HREF=#bbr26_1>26 </A><AUTH>Gerstein</AUTH>,<INITS>M. </INITS>and Levitt,M. (<YR>1996</YR>) In <I>Fourth International Conference on Intelligent Systems for Molecular Biology</I>. AAAI Press, Menlo Park, CA, pp. 59-67.</BB><P>
<bb ID="b27"><A NAME=bb27 HREF=#bbr27_1>27 </A><AUTH>Gotoh</AUTH>,<INITS>O. </INITS>(<YR>1993</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>9</VOL></B>, <PG>361</PG>-370.</BB><P>
<bb ID="b28"><A NAME=bb28 HREF=#bbr28_1>28 </A><AUTH>Myers</AUTH>,<INITS>E.W. </INITS>and Miller,W. (<YR>1988</YR>) <I><JNL>Comput. Applicat. Biosci</JNL></I>., <B><VOL>4</VOL></B>, <PG>11</PG>-17.</BB><P>
<bb ID="b29"><A NAME=bb29 HREF=#bbr29_1>29 </A><AUTH>Van de Peer</AUTH>,<INITS>Y.</INITS>, Jansen,J., De Rijk,P. and De Watcher,R. (<YR>1997</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>25</VOL></B>, <PG>111</PG>-116.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=97169373&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b30"><A NAME=bb30 HREF=#bbr30_1>30 </A><AUTH>Neefs</AUTH>,<INITS>J.M. </INITS>and De Wachter,R. (<YR>1990</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>18</VOL></B>, <PG>5695</PG>-5704.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=91016903&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b31"><A NAME=bb31 HREF=#bbr31_1>31 </A><AUTH>Neefs</AUTH>,<INITS>J.M.</INITS>, Van de Peer,Y., De Rijk,P., Chapelle,S. and De Wachter,R. (<YR>1993</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>21</VOL></B>, <PG>3025</PG>-3049.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=93324409&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b32"><A NAME=bb32 HREF=#bbr32_1>32 </A><AUTH>Subramanian</AUTH>,<INITS>A.R. </INITS>(<YR>1985</YR>) <I><JNL>Essays Biochem</JNL></I>., <B><VOL>21</VOL></B>, <PG>45</PG>-85.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=86220170&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b33"><A NAME=bb33 HREF=#bbr33_1>33 </A><AUTH>Felsenstein</AUTH>,<INITS>J. </INITS>(<YR>1988</YR>) <I><JNL>Cladistics</JNL></I>, <B><VOL>5</VOL></B>, <PG>355</PG>-356.</BB><P>
<bb ID="b34"><A NAME=bb34 HREF=#bbr34_1>34 </A><AUTH>Kimura</AUTH>,<INITS>M. </INITS>(<YR>1980</YR>) <I><JNL>J. Mol. Evol</JNL></I>., <B><VOL>16</VOL></B>, <PG>111</PG>-120.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=81119827&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b35"><A NAME=bb35 HREF=#bbr35_1>35 </A><AUTH>Gotoh</AUTH>,<INITS>O. </INITS>(<YR>1982</YR>) <I><JNL>J. Mol. Biol</JNL></I>., <B><VOL>162</VOL></B>, <PG>705</PG>-708.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=83164207&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b36"><A NAME=bb36 HREF=#bbr36_1>36 </A><AUTH>Gotoh</AUTH>,<INITS>O. </INITS>(<YR>1990</YR>) <I><JNL>Bull. Math. Biol</JNL></I>., <B><VOL>52</VOL></B>, <PG>509</PG>-525.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=90374016&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b37"><A NAME=bb37 HREF=#bbr37_1>37 </A><AUTH>Westhof</AUTH>,<INITS>E. </INITS>and Jaeger,L. (<YR>1992</YR>) <I><JNL>Curr. Opin. Struct. Biol</JNL></I>., <B><VOL>2</VOL></B>, <PG>327</PG>-333.</BB><P>
<bb ID="b38"><A NAME=bb38 HREF=#bbr38_1>38 </A><AUTH>Abrahams</AUTH>,<INITS>J.P.</INITS>, van der Berg,M., van Batenburg,E. and Pleij,C. (<YR>1990</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>18</VOL></B>, <PG>3035</PG>-3044.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=90272411&Dopt=r">MEDLINE Abstract</A></small><P>
<bb ID="b39"><A NAME=bb39 HREF=#bbr39_1>39 </A><AUTH>Grate</AUTH>,<INITS>L. </INITS>(<YR>1995</YR>) In <I>ISMB-95</I>. AAAI Press, Menlo Park, CA, pp. 136-144.</BB><P>
<bb ID="b40"><A NAME=bb40 HREF=#bbr40_1>40 </A><AUTH>Shapiro</AUTH>,<INITS>B.A.</INITS>, Maizel,J., Lipkin,L.E., Currey,K. and Whitney,C. (<YR>1984</YR>) <I><JNL>Nucleic Acids Res</JNL></I>., <B><VOL>12</VOL></B>, <PG>75</PG>-88.</BB> <small><A HREF="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?db=m&form=6&uid=84118751&Dopt=r">MEDLINE Abstract</A></small><P>
</bibl></bm>
<HR>
<A NAME="foot" HREF="#top"><IMG BORDER=0 SRC=/Resources/graphics/icons/top.gif ALT=Top of Page></A>
<P>
<fn ID="2">*To whom correspondence should be addressed. Tel: +44 1223 494449; Fax: +44 1223 494468; Email: <A HREF=MAILTO:cedric.notredame@ebi.ac.uk>cedric.notredame@ebi.ac.uk</A></fn>
<P>
</BODY>
</ART>
</HTML>
